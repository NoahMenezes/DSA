Containers -
    1. vector<int> vec, vector<int> vec = {1,2}, vector<int> vec(3,10), vector<int> vec2(vec1);
    2. functions-> size & capacity, push_back & pop_back, emplace_back, at() or [], front & back. Time complexity: O(1)
    3. erase, insert, clear, empty (costly functions) cause Time complexity: O(n)
Iterators -
    1. vec.begin -> *(vec.begin())=>1 (always)
    2. vec.end ->   (vec.end doesn't point to the location n-1, it points to n), *(vec.end)=random address

Algoirthms

Functors




List (doubly linked list):  list<int> l ={1,2,3,4,5}
    1. push_back & push_front
    2. emplace_back & emplace_front
    3. pop_back & pop_front
Deque (Double Ended Queue): deque<int> d={1,2,3};
    1. push_back & push_front
    2. emplace_back & emplace_front
    3. pop_back & pop_front
    4. !!!!!!! Dequeue-> pop elements from a queue, Deque-> Data type *imp
    5. Random access is possible.
Pair: C++ utility library
    1. pair<int, int> p={3,5};
    2. pair<char, int> p={'a', 1};
Stack: Last in, first out,
    1. An order of stuff placed one over the other.
    2. stack<int> s; push, emplace; top; pop; size; empty; swap;
Queue: First in, First Out
    1. push, emplace; front; pop; size; empty; swap;
    2. queue<int> q; 
Priority Queue:
    1. priority_queue<int> q;
    2. priority_queue<int, vector<int>, greater<int>> q;
    3. push, emplace-- O(logn); top--O(logn); pop -- O(logn); size;empty;
Map or (dictionary ): map<string, int> m; m[key]=value;
    1. (insert, emplace) ; count; erase ; find ; size, empty, erase;
Set: set<int> s;
    1. insert, emplace; count; erase; find; size, empty, erase;


Algorithms

-> Sorting
    1. sort(arr,arr+n)
    2. sort(arr,arr+n, greater<int>())
    3. sort(v.begin(), v.end())